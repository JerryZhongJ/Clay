# 概览

## 想法
这个项目尝试去构建一个有自主性的、持续存在的AI助手。

我觉得LLM模型的对话的交互方式让AI太被动了。用户去激活LLM，LLM便活跃一段时间。即便是各种agent，即便它们具有plan的能力，能够规划、制定todo，也只是让延长了活跃时间。一方面，LLM不会即时反应，除非你发送prompt，或者打断它。另一方面，它的长期记忆依然很差。

这个项目将试验一种想法：如果不用以对话形式使用LLM，而是让LLM不断续写事件流/意识流，能否创造一个能自主、能持续存在的AI。

事件流，是这个项目的主要想法。所有的活动用事件表达，所有的文字也以事件流的形式。LLM的context被看作注意域（attention field， 和transformer的attention不是一个东西），外部的输入作为事件往注意域填写，LLM的思考和反应也是一个事件。

一个事件应该足够的小，它不应该占据注意太大的空间，它应该要让各种事件能够及时地进入注意中。

这个AI助手包含多个模块，它们以异步的形式交互。
- System：这是这个AI助手的最主要模块，它的功能是：
    - 管理注意域
    - 处理事件
    - 调度其他模块
    - 管理AI助手的运行状态
- Concious：这是AI助手的意识所在、灵魂所在。
    - 产生想法
    - 调用其他模块的功能（所有的模块都可以互相调用，但是Conciousy应该是最主要的）
- Memory：保存AI助手中产生的各种信息
    - 存储记忆
    - 搜索记忆
    - 即时闪回
- Terminal：这是AI助手和用户交互的地方。不过，这是AI的终端，不是用户的终端。
    - 显示用户的输入
    - 写入AI助手的反馈。
- Timer：报时，或者设置倒计时
- Internet：让AI助手上网。

## 事件/活动
*事件，也可以叫做活动（Activity），我更青睐后者，但这个文档依然使用“事件”。*

一个事件应该包含：主体（subject），动作（verb），可选的客体（object），可选的细节（details）

基本上，事件可以有这么几类，它们并不互斥：
- UnderCouncious：“潜意识”的活动，不出现在注意域中，但是会出现在事件流中。
- Activate：调用其他模块的功能
- WakeUp：当系统沉睡时，这类事件会将系统唤醒。

事件不是日志。事件是这个AI“大脑”里面产生的各种活动。日志是代码行为。

存储事件的有两个地方：
- 事件流：所有产生的事件，包括注意域中的
- 注意域：部分事件，不能是UnderConcious，且System筛选后的。

## System

这个模块是事件流、注意域的管理者，各个模块的协调者。负责管理其他模块、处理从它们发送的事件，管理注意区域。

### 管理其他模块

其他模块需要注册在System中。它们并且可以注册特定条件的事件。当遇到特定事件时，System会调用它相应的功能。

其他模块向system append事件，而system则直接调用这些模块的功能，不是发送事件。

### 处理事件

首先它需要管理不同模块的事件。不是所有事件都能进入注意域。System对每个模块都有focus值，越focus的模块可以准入更多的事件。每个模块的事件按照重要性排序，优先重要的事件进入，其余只会append在事件流中。

另外，当事件流出现被注册的事件，System需要响应，调用相应功能。

System本身也是模块，它也有功能：比如调整focus值。它也可以注册在自己身上。


### 管理注意域

注意拥有固定大小，当它满了，它要清空至特定大小。



### 产生事件
System本身的各种活动也会产生事件。比如flush注意域会产生事件，这个是“潜意识”事件。

不过有个原则：事件的响应不产生事件。



### 辅助Concious
System还会辅助Concious适应这个系统，即时提供模块使用的提醒。不过Concious应该尽量把System的存在隐藏起来。

在启动的时候，system的注意力域就预装载一些事件，这些事件相当于一个模板：
- 介绍I think
- 介绍能力

System还会remind concious一些事，

## Councious
这个模块负责保持意识，不断产生想法、和意图。

它能产生两个事件：
- think：
- activate：

目前，这个模块基于LLM实现，所以我们说LLM-based Concious

### 编码注意力域

它需要把注意力域编码成自然语言的文本，但是又保持一定程度的结构化。

编码后的文本要有结构：
- 首先要体现出“流”的形式，让LLM更加容易地续写
- 把事件的主体、谓词、客体、细节也能清晰地分别出来


编码后的文本是自然的：
- Concious主体改写为I，也就是“I think”、
- 把系统隐藏起来：
    - 只提取system的remind事件的details
    - 对系统的其他调用，也改成"I"为主体
- 把Concious对其他模块的各种调用写成“I want \<object\> to \<verb\> \<details\> 

### 筛选、解码事件

从LLM的回复中尽量提取出事件

## Memory

它提供功能：
- 记忆remember：被动和主动
  - 被动记忆：被System刷出注意力区域的内容，memory会被动记忆。
  - 主动记忆：concious主动触发记忆，将当前记忆力域的内容存起来。
- 提取记忆：也包含被动和主动
  - 被动：从当前注意力域中联想记忆中可能相关的内容
  - 主动：根据一点线索去记忆里查询、扩展

### 记忆图
*我觉得这个概念应该很成熟了，我应该调研、学习一下*

memory的实现初步想法是用图来表示。每个点有独一无二的label，概述记忆点的内容，也有边连接两个记忆点。边上也有属性表示这个关系，以及关联程度。

和事件一样，记忆点也有大小限制。太大的内容应该拆成多个记忆点。

记忆边的关联程度可以增强，不过是通过反复地记忆来强化。

### 独立管理

记忆是单独地模块，concious没法指示应该如何记忆、记忆什么内容，记忆点的关联之类的。concious能做的，就是多想，多调用主动记忆

## Terminal

想象一下AI助手正在使用一个terminal来和用户交流。

两个功能：
- 显示print：打印用户的输入给ai
- 打字type：发送内容给用户

然而，这和常见的terminal不同，它是异步的！用户可以一边跟ai说话，ai也可以在那说话。
  
需要一个cui。